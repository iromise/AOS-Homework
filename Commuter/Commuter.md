# Commuter
目前，评估多核软件的可扩展性的方法通常为选择一个测试集，然后测量软件性能随着核数的变化趋势，进而使用某种工具来识别出可扩展性的瓶颈。通过这种方法，确实可以使得开发者专注于一些实际的问题，但是这种方法也有对应的缺点

* 不同的测试集或者更高的核数可能会展现不同的瓶颈，开发者很难知道哪个是根本的瓶颈。
* 测试时，软件已经实现了，即使存在瓶颈，可能也只是进行简单的修改，大大改动则需要耗费太多的精力。

一般来说，研究者普遍认为可扩展性是与实现密切相关的，而不会认为是接口的问题或者硬件的问题。但是，作者就想能不能从接口设计触发呢？即接口设计中是否存在可扩展的可能性？我们是否可以在实现之前就找到这些可能性，并通过考虑接口规范来找到内在的可扩展问题，从而可以直接修改接口，避免太多的重复工作量。

一般的，如果一组操作在内存访问上是没有冲突的，我们就认为这组操作时可扩展的。进而，作者定义了可扩展规则，即如果操作是可以交换的，那么这就意味着我们使用接口来区分操作的执行顺序，也就意味着存在一种可扩展的方式来实现这些操作。

此外，作者进一步考虑了可交换性与并发性之间的关系，指出之前关于可交换性的研究更多地是用于讨论并发执行操作的安全性，而作者则是用其来讨论软件的可扩展性，可以作为先前研究补充。

对于上述提到的规则，作者指出这样的规则是很具有直觉性的，即如果操作可交换，那么结果（返回的值以及系统的状态）显然独立于顺序。进而可交换操作之间的通信是不必要的，那么我们就可以消除相关通信，从而就可以生成没有冲突的内存访问。看起来这样做是可以的，但是不够准确，论文中还给出了更加形式化的说明。

作者进一步指出代数运算中的可交换要求太过于严格，难以应用到复杂的具有状态的接口中，因此提出了SIM commutativity，即state-dependent，interface-based，monotonic。并指出如果两个操作可交换，那么久有对应的实现存在，进而就可以把对应的规则应用到实际的接口中。当我们考虑接口时，就不需要所有的操作顺序，只需要最后的结果通过接口是可区分的。而且，这种规则独立于任何具体的实现，允许开发者直接将规则应用到接口设计中。

那么，具体的，如何设计一个可扩展的软件呢？作者指出需要以下两个步骤

1. 分析接口的可扩展性
2. 设计一个在可交换环境下的可扩展的实现

但是想要一个可扩展的实现是很困难的，往往需要考虑很多事情。在一个接口非常复杂时，即使给定了相关的规则，也往往难以考虑所有可交换的情况，因此作者给出了 Commuter 工具，其输入为
* 接口模型
* 简化的，符号化的实现

其会计算一组操作可交换的精确条件并在对应的条件下测试对应的实现是否是无冲突的。那么这种方法就可以集成到开发的过程中，从而引导初始化设计以及实现，增量改进已有的实现，帮助开发者理解一个借口的可交换性。

最后作者从两个方便考虑了可交换规则和 Commuter 的价值

- 探索了 POSIX 的可扩展性，对 18 个简化的 POSIX 文件系统以及虚拟内存系统调用进行了建模，生成了13664 个测试样例对，指出每一个都可以根据规则改为无冲突的。

* 指导了一个研究性系统 sv6 的设计。


相关文献

- Disjoint-access-parallel implementations of strong shared mem- ory primitives
- Laws of order:Expensive synchronization in concurrent algorithms cannot be eliminated.
- Concurrent code and expen- sive instructions
- Real-world concurrency
- Commutativity anal- ysis: A new analysis technique for parallelizing compilers
- Commutative set: A language exten- sion for implicit parallel programming